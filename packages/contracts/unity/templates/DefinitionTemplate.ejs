/* Autogenerated file. Manual edits will not be saved.*/

#nullable enable
using System;
using mud.Client;
using mud.Network.schemas;
using mud.Unity;
using UniRx;
using Property = System.Collections.Generic.Dictionary<string, object>;
using System.Collections.Generic;

namespace <%= namespace %>
{
	public class <%= tableClassName %>Update : TypedRecordUpdate<Tuple<<%= tableClassName %>?, <%= tableClassName %>?>> { }

	public class <%= tableClassName %> : IMudTable
	{
		public readonly static TableId ID = new ("<%= tableNamespace %>", "<%= tableName %>");
		public override TableId GetTableId() {return new ("<%= tableNamespace %>", "<%= tableName %>");}

		<% for (const field of fields) { -%>
			public <%= field.type %>? <%= field.key %>;
		<% } -%>
		
		public override void SetValues(params object[] functionParameters){

			<% var i = 0 -%>
			<% for (const field of fields) { -%>
				<% if (field.type === "long" || field.type === "ulong") { -%> 
				<%= field.key %> = (<%= field.type %>)(int)functionParameters[<%= i -%>];
				<% } else { -%> 
				<%= field.key %> = (<%= field.type %>)functionParameters[<%= i -%>];
				<% } -%> 

				<% i++ -%>
			<% } -%>
		}

		public override bool SetValues(IEnumerable<Property> result)
		{
	
            var hasValues = false;
            foreach (var record in result)
            {
                var attribute = record["attribute"].ToString();
                var value = record["value"];

								switch (attribute)
								{
									<% for (const field of fields) { -%>
									case "<%= field.key %>":
											var <%= field.key %>Value = 
											<% if (field.type == "System.Numerics.BigInteger") { -%>
												new System.Numerics.BigInteger((int)value);
												<% } else { -%>
												(<%= field.type %>)value;
												<% } -%>
											<%= field.key %> = <%= field.key %>Value;	
											hasValues = true;
										break;
									<% } -%>
								}
            }

            return hasValues; 
		}

		public override IMudTable GetTableValue(string key)
		{
			var query = new Query().Find("?value", "?attribute").Where(TableId.ToString(), key, "?attribute", "?value");
            var result = NetworkManager.Instance.ds.Query(query);
            var <%= tableClassName[0].toLowerCase() + tableClassName.substring(1) %> = new <%= tableClassName %>();
            var hasValues = false;

            foreach (var record in result)
            {
                var attribute = record["attribute"].ToString();
                var value = record["value"];

								switch (attribute)
								{
									<% for (const field of fields) { -%>
									case "<%= field.key %>":
											var <%= field.key %>Value = 
											<% if (field.type == "System.Numerics.BigInteger") { -%>
												new System.Numerics.BigInteger((int)value);
												<% } else { -%>
												(<%= field.type %>)value;
												<% } -%>
											<%= tableClassName[0].toLowerCase() + tableClassName.substring(1) %>.<%= field.key %> = <%= field.key %>Value;	
											hasValues = true;
										break;
									<% } -%>
								}
            }

            return hasValues ? <%= tableClassName[0].toLowerCase() + tableClassName.substring(1) %> : null; 
		}

		public static IObservable<<%= tableClassName%>Update> OnRecordUpdate()
		{
			return NetworkManager.Instance.ds.OnDataStoreUpdate.Where(update => update.TableId == ID.ToString() && update.Type == UpdateType.SetField)
			.Select(update => new <%= tableClassName %>Update {
				TableId = update.TableId,
				Key = update.Key,
				Value = update.Value,
				TypedValue = MapUpdates(update.Value)
			});
		}

		public static IObservable<<%= tableClassName%>Update> OnRecordInsert()
		{
			return NetworkManager.Instance.ds.OnDataStoreUpdate.Where(update => update.TableId == ID.ToString() && update.Type == UpdateType.SetRecord)
			.Select(update => new <%= tableClassName %>Update {
				TableId = update.TableId,
				Key = update.Key,
				Value = update.Value,
				TypedValue = MapUpdates(update.Value)
			});
		}

		public static IObservable<<%= tableClassName%>Update> OnRecordDelete()
		{
			return NetworkManager.Instance.ds.OnDataStoreUpdate.Where(update => update.TableId == ID.ToString() && update.Type == UpdateType.DeleteRecord)
			.Select(update => new <%= tableClassName %>Update {
				TableId = update.TableId,
				Key = update.Key,
				Value = update.Value,
				TypedValue = MapUpdates(update.Value) 
			});
		}

		public static Tuple<<%= tableClassName %>?, <%= tableClassName %>?> MapUpdates(Tuple<Property?, Property?> value)
		{
			<%= tableClassName %>? current = null;
			<%= tableClassName %>? previous = null;

			if (value.Item1 != null) 
			{
				try {
					current = new <%= tableClassName %>
					{
						<% for (const field of fields) { -%>
							<%= field.key %> = value.Item1.TryGetValue("<%= field.key %>", out var <%= field.key %>Val) 
									? (<%= field.type %>)<%= field.key %>Val : default,
						<% } -%>
					};
				} catch (InvalidCastException)
				{
					current = new <%= tableClassName %> 
					{
						<% for (const field of fields) { -%>
							<%= field.key %> = 	null,
						<% } -%>	
					};
				}
			}

			if (value.Item2 != null)
			{
				try {
					previous = new <%= tableClassName %>
					{
						<% for (const field of fields) { -%>
							<%= field.key %> = value.Item2.TryGetValue("<%= field.key %>", out var <%= field.key %>Val) 
									? (<%= field.type %>)<%= field.key %>Val : default,
						<% } -%>
					};
				} catch (InvalidCastException)
				{
					previous = new  <%= tableClassName %>
					{
						<% for (const field of fields) { -%>
							<%= field.key %> = 	null,
						<% } -%>	
					};
				}
		
			}

			return new Tuple<<%= tableClassName %>?, <%= tableClassName %>?> (current, previous);
		}
	}
}
